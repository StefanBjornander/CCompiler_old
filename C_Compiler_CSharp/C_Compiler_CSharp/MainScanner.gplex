%namespace CCompiler_Main

%using CCompiler;
%using System.Numerics;

%{
  public static FileInfo Path = null;
  public static int Line = 1;

  private static IDictionary<char,char> m_slashMap =
    new Dictionary<char,char>() {
                    // ASCII value
      {'0', '\0'},  //  0
      {'a', '\a'},  //  7
      {'b', '\b'},  //  8
      {'f', '\f'},  // 12
      {'n', '\n'},  // 10
      {'r', '\r'},  // 13
      {'t', '\t'},  //  9
      {'v', '\v'},  // 11
      {'\'', '\''}, // 39
      {'\"', '\"'}, // 34
      {'?', '?'},   // 63
      {'\\', '\\'}  // 92
    };

  public static string SlashToChar(string text) {
    StringBuilder buffer = new StringBuilder(text);
    buffer.Append("\0\0\0");

    for (int index = 0; buffer[index] != '\0'; ++index) {
      if (buffer[index] == '\\') {
        char char1 = buffer[index + 1],
             char2 = buffer[index + 2],
             char3 = buffer[index + 3];

        if (m_slashMap.ContainsKey(char1)) {
          buffer.Remove(index, 2);
          buffer.Insert(index, m_slashMap[char1]);
        }
        else if (IsOctal(char1) && IsOctal(char2) && IsOctal(char3)) {
          int octValue = 64 * CharToOctal(char1) +
                          8 * CharToOctal(char2) +
                              CharToOctal(char3);
          Assert.Error(octValue < 256, Message.Invalid_octal_sequence);
          buffer.Remove(index, 4);
          buffer.Insert(index, (char) octValue);
        }
        else if (IsOctal(char1) && IsOctal(char2)) {
          int octValue = 8 * CharToOctal(char1) +
                             CharToOctal(char2);
          buffer.Remove(index, 3);
          buffer.Insert(index, (char)octValue);
        }
        else if (IsOctal(char1)) {
          int octValue = CharToOctal(char1);
          buffer.Remove(index, 2);
          buffer.Insert(index, (char) octValue);
        }
        else if (char.ToLower(char1) == 'x') {
          if (IsHex(char1) && IsHex(char2)) {
            int hexValue = 16 * CharToHex(char1) + CharToHex(char2);
            buffer.Remove(index, 3);
            buffer.Insert(index, (char) hexValue);
          }
          else if (IsHex(char1)) {
            int hexValue = CharToHex(char1);
            buffer.Remove(index, 2);
            buffer.Insert(index, (char) hexValue);
          }
          else {
            Assert.Error(char1.ToString(),
                         Message.Invalid_hexadecimal_code);
          }
        }
        else {
          Assert.Error(buffer[index + 1].ToString(),
                       Message.Invalid_slash_sequence);
        }
      }
    }

    buffer.Remove(buffer.Length - 3, 3);
    return buffer.ToString();
  }

  private static bool IsOctal(char c) {
    return "01234567".Contains(c.ToString());
  }
  
  private static bool IsHex(char c) {
    return "0123456789abcdef".Contains(c.ToString().ToLower());
  }
  
  private static int CharToOctal(char c) {
    return "01234567".IndexOf(c);
  }
  
  private static int CharToHex(char c) {
    return "0123456789abcdef".IndexOf(c.ToString().ToLower());
  }
%}

DECIMAL_VALUE [\+\-]?[1-9][0-9]*
OCTAL_VALUE [\+\-]?0[0-7]*
HEXADECIMAL_VALUE [\+\-]?0[xX][0-9a-fA-F]+
POSTFIX ([uU]?[sSlL]?)|([sSlL]?[uU]?)
INTEGRAL_VALUE ({DECIMAL_VALUE}|{OCTAL_VALUE}|{HEXADECIMAL_VALUE}){POSTFIX}

DECIMAL_PART [\+\-]?([0-9]+|[0-9]+\.[0-9]*|\.[0-9]+)
EXPONENT_PART (([eE][\+\-]?[0-9]+)?|[0-9]+[eE][\+\-]?[0-9]+)([fF]|[lL])?
FLOATING_VALUE {DECIMAL_PART}{EXPONENT_PART}

CHAR_VALUE \'(\\\'|[^'])*\'
STRING_VALUE \"(\\\"|[^"])*\"

REGISTER_NAME "register_"[a-z]+
NAME [a-zA-Z_$][a-zA-Z0-9_]*

PATH_LINE \$.*\$
WHITE_SPACE [ \t\r\n\f]

%%
"auto"          { return ((int) Tokens.AUTO);            }
"break"         { return ((int) Tokens.BREAK);           }
"case"          { return ((int) Tokens.CASE);            }
"carry_flag"    { return ((int) Tokens.CARRY_FLAG);      }
"char"          { return ((int) Tokens.CHAR);            }
"const"         { return ((int) Tokens.CONSTANT);        }
"continue"      { return ((int) Tokens.CONTINUE);        }
"default"       { return ((int) Tokens.DEFAULT);         }
"do"            { return ((int) Tokens.DO);              }
"double"        { return ((int) Tokens.DOUBLE);          }
"else"          { return ((int) Tokens.ELSE);            }
"enum"          { return ((int) Tokens.ENUM);            }
"extern"        { return ((int) Tokens.EXTERN);          }
"float"         { return ((int) Tokens.FLOAT);           }
"for"           { return ((int) Tokens.FOR);             }
"goto"          { return ((int) Tokens.GOTO);            }
"int"           { return ((int) Tokens.INT);             }
"interrupt"     { return ((int) Tokens.INTERRUPT);       }
"if"            { return ((int) Tokens.IF);              }
"jump_register" { return ((int) Tokens.JUMP_REGISTER);   }
"long"          { return ((int) Tokens.LONG);            }
"register"      { return ((int) Tokens.REGISTER);        }
"return"        { return ((int) Tokens.RETURN);          }
"short"         { return ((int) Tokens.SHORT);           }
"signed"        { return ((int) Tokens.SIGNED);          }
"sizeof"        { return ((int) Tokens.SIZEOF);          }
"stack_top"     { return ((int) Tokens.STACK_TOP);       }
"static"        { return ((int) Tokens.STATIC);          }
"struct"        { return ((int) Tokens.STRUCT);          }
"switch"        { return ((int) Tokens.SWITCH);          }
"syscall"       { return ((int) Tokens.SYSCALL);         }
"typedef"       { return ((int) Tokens.TYPEDEF);         }
"union"         { return ((int) Tokens.UNION);           }
"unsigned"      { return ((int) Tokens.UNSIGNED);        }
"while"         { return ((int) Tokens.WHILE);           }
"void"          { return ((int) Tokens.VOID);            }
"volatile"      { return ((int) Tokens.VOLATILE);        }

";" { return ((int) Tokens.SEMICOLON); }
":" { return ((int) Tokens.COLON); }
"," { return ((int) Tokens.COMMA); }

"." { return ((int) Tokens.DOT); }
"->" { return ((int) Tokens.ARROW); }
"..." { return ((int) Tokens.ELLIPSE); }

"(" { return ((int) Tokens.LEFT_PARENTHESIS); }
")" { return ((int) Tokens.RIGHT_PARENTHESIS); }
"{" { return ((int) Tokens.LEFT_BLOCK); }
"}" { return ((int) Tokens.RIGHT_BLOCK); }
"[" { return ((int) Tokens.LEFT_SQUARE); }
"]" { return ((int) Tokens.RIGHT_SQUARE); }

"*" { return ((int) Tokens.ASTERRISK); }
"?" { return ((int) Tokens.QUESTION_MARK); }

"||" { return ((int) Tokens.LOGICAL_OR); }
"&&" { return ((int) Tokens.LOGICAL_AND); }
"!" { return ((int) Tokens.LOGICAL_NOT); }
"&" { return ((int) Tokens.AMPERSAND); }
"^" { return ((int) Tokens.BITWISE_XOR); }
"|" { return ((int) Tokens.BITWISE_OR); }
"~" { return ((int) Tokens.BITWISE_NOT); }

"==" { return ((int) Tokens.EQUAL); }
"!=" { return ((int) Tokens.NOT_EQUAL); }

"<"  { return ((int) Tokens.LESS_THAN); }
"<=" { return ((int) Tokens.LESS_THAN_EQUAL); }
">"  { return ((int) Tokens.GREATER_THAN); }
">=" { return ((int) Tokens.GREATER_THAN_EQUAL); }

"<<" { return ((int) Tokens.LEFT_SHIFT); }
">>" { return ((int) Tokens.RIGHT_SHIFT); }

"+" { return ((int) Tokens.PLUS); }
"-" { return ((int) Tokens.MINUS); }

"/" { return ((int) Tokens.DIVIDE); }
"%" { return ((int) Tokens.MODULO); }

"++" { return ((int) Tokens.INCREMENT); }
"--" { return ((int) Tokens.DECREMENT); }

"="  { return ((int) Tokens.ASSIGN); }
"+="  { return ((int) Tokens.ADD_ASSIGN); }
"-="  { return ((int) Tokens.SUBTRACT_ASSIGN); }
"*="  { return ((int) Tokens.MULTIPLY_ASSIGN); }
"/="  { return ((int) Tokens.DIVIDE_ASSIGN); }
"%="  { return ((int) Tokens.MODULO_ASSIGN); }
"<<=" { return ((int) Tokens.LEFT_SHIFT_ASSIGN); }
">>=" { return ((int) Tokens.RIGHT_SHIFT_ASSIGN); }
"&="  { return ((int) Tokens.AND_ASSIGN); }
"^="  { return ((int) Tokens.XOR_ASSIGN); }
"|="  { return ((int) Tokens.OR_ASSIGN); }

{REGISTER_NAME} {
  { Register register;
    string text = yytext.Substring(9);

    if (Enum.TryParse<Register>(text, out register)) {
      yylval.register = register;
      return ((int) Tokens.REGISTER_NAME);
    }
    
    Assert.Error(text, Message.Unknown_register);
  }
}

{NAME} {
  { Symbol symbol = SymbolTable.CurrentTable.LookupSymbol(yytext);

    if ((symbol != null) && symbol.IsTypedef()) {
      yylval.type = symbol.Type;
      return ((int) Tokens.TYPEDEF_NAME);
    }
    else {
      yylval.name = yytext;
      return ((int) Tokens.NAME);
    }
  }
}

{INTEGRAL_VALUE} {
  { string text = yytext.Trim().ToLower();

    bool minus = false;
    if (text.StartsWith("+")) {
      text = text.Substring(1);
    }
    else if (text.StartsWith("-")) {
      minus = true;
      text = text.Substring(1);
    }
    
    int fromBase;
    if (text.StartsWith("0x")) {
      fromBase = 16;
      text = text.Substring(2);
    }
    else if (text.StartsWith("0")) {
      fromBase = 8;
    }
    else {
      fromBase = 10;
    }

    CCompiler.Type type;
    if (text.EndsWith("us") || text.EndsWith("su")) {
      type = CCompiler.Type.UnsignedShortIntegerType;
      text = text.Substring(0, text.Length - 2);
    }
    else if (text.EndsWith("ul") || text.EndsWith("lu")) {
      type = CCompiler.Type.UnsignedLongIntegerType;
      text = text.Substring(0, text.Length - 2);
    }
    else if (text.EndsWith("u")) {
      type = CCompiler.Type.UnsignedIntegerType;
      text = text.Substring(0, text.Length - 1);
    }
    else if (text.EndsWith("s")) {
      type = CCompiler.Type.SignedShortIntegerType;
      text = text.Substring(0, text.Length - 1);
    }
    else if (text.EndsWith("l")) {
      type = CCompiler.Type.SignedLongIntegerType;
      text = text.Substring(0, text.Length - 1);
    }
    else {
      type = CCompiler.Type.SignedIntegerType;
    }
    
  
    try {
      ulong unsignedValue = Convert.ToUInt64(text, fromBase);
      BigInteger bigValue = new BigInteger(unsignedValue);

      if (minus) {
        bigValue = -bigValue;
      }

      yylval.symbol = new Symbol(type, bigValue);
      /*yylval.symbol.StaticSymbol =
        ConstantExpression.Value(yylval.symbol.UniqueName, type, bigValue);
      SymbolTable.StaticSet.Add(yylval.symbol.StaticSymbol);*/
    }
    catch (OverflowException) {
      Assert.Error("X " + type + ": " + text, Message.Value_overflow);
    }

    return ((int) Tokens.VALUE);
  }
}

{FLOATING_VALUE} {
  { string text = yytext.ToLower();
    CCompiler.Type type = CCompiler.Type.DoubleType;

    if (text.EndsWith("f")) {
      type = CCompiler.Type.FloatType;
      text = text.Substring(0, text.Length - 1);
    }
    else if (text.EndsWith("l")) {
      type = CCompiler.Type.LongDoubleType;
      text = text.Substring(0, text.Length - 1);
    }

    try {
      decimal value = decimal.Parse(text, NumberStyles.Float);
      yylval.symbol = new Symbol(type, value);
      /*yylval.symbol.StaticSymbol =
        ConstantExpression.Value(yylval.symbol.UniqueName, type, value);
      SymbolTable.StaticSet.Add(yylval.symbol.StaticSymbol);*/
    }
    catch (OverflowException) {
      Assert.Error("Y " + type + ": " + text, Message.Value_overflow);
    }

    return ((int) Tokens.VALUE);
  }
}

{CHAR_VALUE} {
  { CCompiler.Type type = new CCompiler.Type(Sort.Signed_Char);
    string text = SlashToChar(yytext);
    Assert.Error(text.Length == 3, yytext, Message.Invalid_char_sequence);
    yylval.symbol = new Symbol(type, (BigInteger) ((int) text[1]));
    return ((int) Tokens.VALUE);
  }
}

{STRING_VALUE} {
  { CCompiler.Type type = new CCompiler.Type(Sort.String);
    string text = SlashToChar(yytext);
    object value = text.Substring(1, text.Length - 2);
    yylval.symbol = new Symbol(type, value);
    SymbolTable.StaticSet.Add(ConstantExpression.Value(yylval.symbol));
    return ((int) Tokens.VALUE);
  }
}

{PATH_LINE} {
  { string text = yytext.Substring(1, yyleng - 2);
    int index = text.IndexOf(',');
    Path = new FileInfo(text.Substring(0, index).Replace("+", " "));
    Line = int.Parse(text.Substring(index + 1)) - 1;
  }
}

{WHITE_SPACE} {
  if (yytext.Equals("\n")) {
    ++Line;
  }
}

. { Assert.Error(yytext, Message.Unknown_character); }
